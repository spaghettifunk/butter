//! Metal shader management.
//!
//! Handles loading Metal Shading Language (MSL) source files and
//! compiling them to MTLLibrary/MTLFunction objects.

const std = @import("std");
const metal_context = @import("context.zig");
const logger = @import("../../core/logging.zig");

const MetalContext = metal_context.MetalContext;
const sel = metal_context.sel_registerName;
const msg = metal_context.msgSend;
const msg1 = metal_context.msgSend1;
const msg2 = metal_context.msgSend2;
const msg3 = metal_context.msgSend3;
const getClass = metal_context.objc_getClass;
const release = metal_context.release;

/// Shader stage enumeration
pub const ShaderStage = enum {
    vertex,
    fragment,
    compute,
};

/// Metal shader module wrapper
pub const MetalShaderModule = struct {
    library: metal_context.MTLLibrary = null,
    function: metal_context.MTLFunction = null,
    stage: ShaderStage = .vertex,
};

/// Load shader from MSL source file
/// The MSL files are generated by spirv-cross during build and placed in build/shaders/
pub fn loadFromMSL(context: *MetalContext, msl_path: []const u8, function_name: []const u8) ?MetalShaderModule {
    const device = context.device orelse {
        logger.err("Cannot load shader: no Metal device", .{});
        return null;
    };

    // Read MSL source file
    const file = std.fs.cwd().openFile(msl_path, .{}) catch |err| {
        logger.err("Failed to open shader file '{s}': {}", .{ msl_path, err });
        return null;
    };
    defer file.close();

    // Read file with null terminator for C string compatibility
    const source = file.readToEndAlloc(std.heap.page_allocator, 1024 * 1024) catch |err| {
        logger.err("Failed to read shader file '{s}': {}", .{ msl_path, err });
        return null;
    };
    defer std.heap.page_allocator.free(source);

    // Allocate buffer with null terminator for C string compatibility
    const source_with_null = std.heap.page_allocator.allocSentinel(u8, source.len, 0) catch |err| {
        logger.err("Failed to allocate shader source buffer: {}", .{err});
        return null;
    };
    defer std.heap.page_allocator.free(source_with_null);
    @memcpy(source_with_null, source);

    // Create NSString from source
    const ns_string_class = getClass("NSString") orelse {
        logger.err("Failed to get NSString class", .{});
        return null;
    };

    // Create NSString with UTF8 encoding
    const source_string = msg1(
        ?*anyopaque,
        ns_string_class,
        sel("stringWithUTF8String:"),
        source_with_null.ptr,
    );
    if (source_string == null) {
        logger.err("Failed to create NSString from shader source", .{});
        return null;
    }

    // Compile shader: newLibraryWithSource:options:error:
    var error_ptr: ?*anyopaque = null;
    const library = msg3(
        ?*anyopaque,
        device,
        sel("newLibraryWithSource:options:error:"),
        source_string,
        @as(?*anyopaque, null), // MTLCompileOptions
        &error_ptr,
    );

    if (library == null) {
        if (error_ptr) |err| {
            const desc = msg(?*anyopaque, err, sel("localizedDescription"));
            if (desc) |d| {
                const c_str = msg([*:0]const u8, d, sel("UTF8String"));
                logger.err("Shader compilation failed for '{s}': {s}", .{ msl_path, c_str });
            }
        } else {
            logger.err("Shader compilation failed for '{s}': unknown error", .{msl_path});
        }
        return null;
    }

    // Get function from library
    // Create NSString for function name
    const func_name_str = msg1(
        ?*anyopaque,
        ns_string_class,
        sel("stringWithUTF8String:"),
        function_name.ptr,
    );
    if (func_name_str == null) {
        logger.err("Failed to create function name string", .{});
        release(library);
        return null;
    }

    const function = msg1(?*anyopaque, library, sel("newFunctionWithName:"), func_name_str);
    if (function == null) {
        logger.err("Failed to get function '{s}' from library", .{function_name});
        release(library);
        return null;
    }

    logger.debug("Loaded shader '{s}' function '{s}'", .{ msl_path, function_name });

    return MetalShaderModule{
        .library = library,
        .function = function,
        .stage = .vertex, // Will be set by caller
    };
}

/// Load shader from pre-compiled metallib file (for production)
pub fn loadFromMetalLib(context: *MetalContext, metallib_path: []const u8, function_name: []const u8) ?MetalShaderModule {
    const device = context.device orelse {
        logger.err("Cannot load shader: no Metal device", .{});
        return null;
    };

    // Create NSString for path
    const ns_string_class = getClass("NSString") orelse {
        logger.err("Failed to get NSString class", .{});
        return null;
    };

    const path_string = msg1(
        ?*anyopaque,
        ns_string_class,
        sel("stringWithUTF8String:"),
        metallib_path.ptr,
    );
    if (path_string == null) {
        logger.err("Failed to create path string", .{});
        return null;
    }

    // Create NSURL from path
    const ns_url_class = getClass("NSURL") orelse {
        logger.err("Failed to get NSURL class", .{});
        return null;
    };

    const url = msg1(?*anyopaque, ns_url_class, sel("fileURLWithPath:"), path_string);
    if (url == null) {
        logger.err("Failed to create URL from path", .{});
        return null;
    }

    // Load library from URL: newLibraryWithURL:error:
    var error_ptr: ?*anyopaque = null;
    const library = msg2(
        ?*anyopaque,
        device,
        sel("newLibraryWithURL:error:"),
        url,
        &error_ptr,
    );

    if (library == null) {
        if (error_ptr) |err| {
            const desc = msg(?*anyopaque, err, sel("localizedDescription"));
            if (desc) |d| {
                const c_str = msg([*:0]const u8, d, sel("UTF8String"));
                logger.err("Failed to load metallib '{s}': {s}", .{ metallib_path, c_str });
            }
        }
        return null;
    }

    // Get function from library
    const func_name_str = msg1(
        ?*anyopaque,
        ns_string_class,
        sel("stringWithUTF8String:"),
        function_name.ptr,
    );
    if (func_name_str == null) {
        release(library);
        return null;
    }

    const function = msg1(?*anyopaque, library, sel("newFunctionWithName:"), func_name_str);
    if (function == null) {
        logger.err("Failed to get function '{s}' from metallib", .{function_name});
        release(library);
        return null;
    }

    return MetalShaderModule{
        .library = library,
        .function = function,
        .stage = .vertex,
    };
}

/// Destroy a shader module and release resources
pub fn destroy(module: *MetalShaderModule) void {
    if (module.function) |func| {
        release(func);
    }
    if (module.library) |lib| {
        release(lib);
    }
    module.* = .{};
}

/// Check if shader module is valid
pub fn isValid(module: *const MetalShaderModule) bool {
    return module.library != null and module.function != null;
}

/// Get the MTLFunction handle
pub fn getFunction(module: *const MetalShaderModule) ?*anyopaque {
    return module.function;
}
