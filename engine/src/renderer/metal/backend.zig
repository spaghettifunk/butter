//! Metal Backend Implementation
//!
//! This is the Metal backend for macOS native rendering.

const std = @import("std");
const builtin = @import("builtin");
const build_options = @import("build_options");
const metal_context = @import("context.zig");
const metal_buffer = @import("buffer.zig");
const metal_shader = @import("shader.zig");
const metal_pipeline = @import("pipeline.zig");
const metal_texture = @import("texture.zig");
const renderer = @import("../renderer.zig");
const logger = @import("../../core/logging.zig");
const engine_context = @import("../../context.zig");
const resource_types = @import("../../resources/types.zig");
const geometry_types = @import("../../systems/geometry.zig");
const math_types = @import("../../math/types.zig");
const math = @import("../../math/math.zig");

// GLFW import for getting native Cocoa window
const glfw = @cImport({
    @cDefine("GLFW_EXPOSE_NATIVE_COCOA", "1");
    @cInclude("GLFW/glfw3.h");
    @cInclude("GLFW/glfw3native.h");
});

// Conditional ImGui C bindings - only include when ImGui is enabled
const imgui_glfw = if (build_options.enable_imgui) @cImport({
    @cInclude("dcimgui_impl_glfw.h");
}) else struct {};

const imgui_metal = if (build_options.enable_imgui) @cImport({
    @cInclude("cimgui_impl_metal.h");
}) else struct {};

// Convenient aliases
const MetalContext = metal_context.MetalContext;
const sel = metal_context.sel_registerName;
const msg = metal_context.msgSend;
const msg1 = metal_context.msgSend1;
const msg2 = metal_context.msgSend2;
const msg3 = metal_context.msgSend3;
const msg4 = metal_context.msgSend4;
const msg5 = metal_context.msgSend5;
const getClass = metal_context.objc_getClass;
const release = metal_context.release;

/// Metal-specific GPU data for geometry
pub const MetalGeometryGpuData = struct {
    vertex_buffer: metal_buffer.MetalBuffer = .{},
    index_buffer: metal_buffer.MetalBuffer = .{},
};

/// Metal backend state
pub const MetalBackend = struct {
    context: MetalContext = .{},
    frame_number: u64 = 0,

    // Shaders and pipeline
    vertex_shader: metal_shader.MetalShaderModule = .{},
    fragment_shader: metal_shader.MetalShaderModule = .{},
    material_pipeline: metal_pipeline.MetalPipeline = .{},

    // Global uniform buffers (double-buffered)
    global_uniform_buffers: [metal_context.MAX_FRAMES_IN_FLIGHT]metal_buffer.MetalBuffer = [_]metal_buffer.MetalBuffer{.{}} ** metal_context.MAX_FRAMES_IN_FLIGHT,

    // Default texture
    default_texture: metal_texture.MetalTexture = .{},

    // ImGui state
    imgui_initialized: bool = false,
    imgui_render_pass_desc: ?*anyopaque = null,

    pub fn initialize(self: *MetalBackend, application_name: []const u8) bool {
        _ = application_name;

        // Create Metal device
        const device = MTLCreateSystemDefaultDevice();
        if (device == null) {
            logger.err("Failed to create Metal device - no GPU found", .{});
            return false;
        }
        self.context.device = device;
        logger.debug("Metal device created.", .{});

        // Create command queue
        const command_queue = msg(?*anyopaque, device, sel("newCommandQueue"));
        if (command_queue == null) {
            logger.err("Failed to create Metal command queue", .{});
            return false;
        }
        self.context.command_queue = command_queue;
        logger.debug("Metal command queue created.", .{});

        // Create Metal layer and attach to window
        if (!self.createMetalLayer()) {
            logger.err("Failed to create Metal layer.", .{});
            return false;
        }

        // Get initial drawable size and create depth texture
        if (!self.createDepthTexture()) {
            logger.err("Failed to create depth texture.", .{});
            return false;
        }

        // Load shaders from MSL files generated by spirv-cross
        if (!self.loadShaders()) {
            logger.err("Failed to load shaders.", .{});
            return false;
        }

        // Create pipeline
        if (!self.createPipeline()) {
            logger.err("Failed to create pipeline.", .{});
            return false;
        }

        // Create global uniform buffers
        if (!self.createUniformBuffers()) {
            logger.err("Failed to create uniform buffers.", .{});
            return false;
        }

        // Create default texture
        if (metal_texture.createDefaultTexture(&self.context)) |tex| {
            self.default_texture = tex;
            logger.debug("Default texture created.", .{});
        } else {
            logger.warn("Failed to create default texture.", .{});
        }

        logger.info("Metal renderer initialized successfully.", .{});
        return true;
    }

    pub fn shutdown(self: *MetalBackend) void {
        // Wait for GPU to finish
        if (self.context.command_queue) |queue| {
            const cmd_buf = msg(?*anyopaque, queue, sel("commandBuffer"));
            if (cmd_buf) |buf| {
                _ = msg(void, buf, sel("commit"));
                _ = msg(void, buf, sel("waitUntilCompleted"));
            }
        }

        // Release default texture
        metal_texture.destroy(&self.default_texture);

        // Release uniform buffers
        for (&self.global_uniform_buffers) |*buf| {
            metal_buffer.destroy(buf);
        }

        // Release pipeline
        metal_pipeline.destroy(&self.context, &self.material_pipeline);

        // Release shaders
        metal_shader.destroy(&self.vertex_shader);
        metal_shader.destroy(&self.fragment_shader);

        // Release depth texture
        if (self.context.depth_texture) |tex| {
            logger.debug("Releasing depth texture...", .{});
            release(tex);
            self.context.depth_texture = null;
        }

        // Release Metal layer
        if (self.context.layer) |layer| {
            logger.debug("Releasing Metal layer...", .{});
            release(layer);
            self.context.layer = null;
        }

        // Release command queue
        if (self.context.command_queue) |queue| {
            logger.debug("Releasing Metal command queue...", .{});
            release(queue);
            self.context.command_queue = null;
        }

        // Release device
        if (self.context.device) |device| {
            logger.debug("Releasing Metal device...", .{});
            release(device);
            self.context.device = null;
        }

        logger.info("Metal renderer shutdown.", .{});
    }

    pub fn resized(self: *MetalBackend, width: u16, height: u16) void {
        if (width == 0 or height == 0) return;

        self.context.framebuffer_width = width;
        self.context.framebuffer_height = height;

        // Update layer drawable size
        if (self.context.layer) |layer| {
            const size = metal_context.CGSize{
                .width = @floatFromInt(width),
                .height = @floatFromInt(height),
            };
            _ = msg1(void, layer, sel("setDrawableSize:"), size);
        }

        // Recreate depth texture at new size
        if (self.context.depth_texture) |tex| {
            release(tex);
            self.context.depth_texture = null;
        }
        _ = self.createDepthTexture();

        logger.debug("Metal resized to {}x{}", .{ width, height });
    }

    pub fn beginFrame(self: *MetalBackend, _: f32) bool {
        const layer = self.context.layer orelse return false;
        const queue = self.context.command_queue orelse return false;

        // Get next drawable from layer
        const drawable = msg(?*anyopaque, layer, sel("nextDrawable"));
        if (drawable == null) {
            logger.warn("Failed to get next drawable", .{});
            return false;
        }
        self.context.current_drawable = drawable;

        // Create command buffer
        const command_buffer = msg(?*anyopaque, queue, sel("commandBuffer"));
        if (command_buffer == null) {
            logger.err("Failed to create command buffer", .{});
            return false;
        }
        self.context.current_command_buffer = command_buffer;

        // Get drawable texture
        const drawable_texture = msg(?*anyopaque, drawable, sel("texture"));
        if (drawable_texture == null) {
            logger.err("Failed to get drawable texture", .{});
            return false;
        }

        // Create render pass descriptor
        const rpd_class = getClass("MTLRenderPassDescriptor") orelse return false;
        const render_pass_desc = msg(?*anyopaque, rpd_class, sel("renderPassDescriptor"));
        if (render_pass_desc == null) {
            logger.err("Failed to create render pass descriptor", .{});
            return false;
        }

        // Configure color attachment
        const color_attachments = msg(?*anyopaque, render_pass_desc, sel("colorAttachments"));
        if (color_attachments) |attachments| {
            const color_attachment = msg1(?*anyopaque, attachments, sel("objectAtIndexedSubscript:"), @as(u64, 0));
            if (color_attachment) |attachment| {
                _ = msg1(void, attachment, sel("setTexture:"), drawable_texture);
                _ = msg1(void, attachment, sel("setLoadAction:"), metal_context.MTLLoadAction.Clear);
                _ = msg1(void, attachment, sel("setStoreAction:"), metal_context.MTLStoreAction.Store);
                // Cornflower blue clear color
                const clear_color = metal_context.MTLClearColor{
                    .red = 0.392,
                    .green = 0.584,
                    .blue = 0.929,
                    .alpha = 1.0,
                };
                _ = msg1(void, attachment, sel("setClearColor:"), clear_color);
            }
        }

        // Configure depth attachment
        if (self.context.depth_texture) |depth_tex| {
            const depth_attachment = msg(?*anyopaque, render_pass_desc, sel("depthAttachment"));
            if (depth_attachment) |attachment| {
                _ = msg1(void, attachment, sel("setTexture:"), depth_tex);
                _ = msg1(void, attachment, sel("setLoadAction:"), metal_context.MTLLoadAction.Clear);
                _ = msg1(void, attachment, sel("setStoreAction:"), metal_context.MTLStoreAction.DontCare);
                _ = msg1(void, attachment, sel("setClearDepth:"), @as(f64, 1.0));
            }
        }

        // Create render command encoder
        const encoder = msg1(?*anyopaque, command_buffer, sel("renderCommandEncoderWithDescriptor:"), render_pass_desc);
        if (encoder == null) {
            logger.err("Failed to create render command encoder", .{});
            return false;
        }
        self.context.current_render_encoder = encoder;

        // Store render pass descriptor for ImGui
        self.imgui_render_pass_desc = render_pass_desc;

        // Set viewport
        const viewport = metal_context.MTLViewport{
            .originX = 0,
            .originY = 0,
            .width = @floatFromInt(self.context.framebuffer_width),
            .height = @floatFromInt(self.context.framebuffer_height),
            .znear = 0.0,
            .zfar = 1.0,
        };
        _ = msg1(void, encoder, sel("setViewport:"), viewport);

        // Set scissor rect
        const scissor = metal_context.MTLScissorRect{
            .x = 0,
            .y = 0,
            .width = self.context.framebuffer_width,
            .height = self.context.framebuffer_height,
        };
        _ = msg1(void, encoder, sel("setScissorRect:"), scissor);

        // Set front face winding and cull mode (match Vulkan backend)
        _ = msg1(void, encoder, sel("setFrontFacingWinding:"), metal_context.MTLWinding.CounterClockwise);
        _ = msg1(void, encoder, sel("setCullMode:"), metal_context.MTLCullMode.Back);

        // Bind pipeline
        metal_pipeline.bind(encoder, &self.material_pipeline);

        // Bind global uniform buffer (data is uploaded via updateUBO from renderer system)
        const frame_idx = self.context.frame_index;
        if (self.global_uniform_buffers[frame_idx].handle) |ubo| {
            // setVertexBuffer:offset:atIndex: - UBO at buffer index 0
            _ = msg3(void, encoder, sel("setVertexBuffer:offset:atIndex:"), ubo, @as(u64, 0), @as(u64, 0));
        }

        return true;
    }

    pub fn endFrame(self: *MetalBackend, delta_time: f32) bool {
        _ = delta_time;

        const encoder = self.context.current_render_encoder orelse return false;
        const command_buffer = self.context.current_command_buffer orelse return false;
        const drawable = self.context.current_drawable orelse return false;

        // End encoding
        _ = msg(void, encoder, sel("endEncoding"));

        // Present drawable
        _ = msg1(void, command_buffer, sel("presentDrawable:"), drawable);

        // Commit command buffer
        _ = msg(void, command_buffer, sel("commit"));

        // Clear frame state
        self.context.current_render_encoder = null;
        self.context.current_command_buffer = null;
        self.context.current_drawable = null;

        // Advance frame index for double-buffering
        self.context.frame_index = (self.context.frame_index + 1) % metal_context.MAX_FRAMES_IN_FLIGHT;
        self.frame_number += 1;

        return true;
    }

    /// Create a texture from raw pixel data
    pub fn createTexture(
        self: *MetalBackend,
        texture: *resource_types.Texture,
        width: u32,
        height: u32,
        channel_count: u8,
        has_transparency: bool,
        pixels: []const u8,
    ) bool {
        _ = has_transparency;

        const metal_tex = metal_texture.create(&self.context, width, height, channel_count, pixels) orelse {
            logger.err("Failed to create Metal texture", .{});
            return false;
        };

        // Allocate MetalTexture on heap and store pointer
        const tex_ptr = std.heap.page_allocator.create(metal_texture.MetalTexture) catch {
            logger.err("Failed to allocate Metal texture storage", .{});
            metal_texture.destroy(@constCast(&metal_tex));
            return false;
        };
        tex_ptr.* = metal_tex;

        texture.internal_data = tex_ptr;
        texture.width = width;
        texture.height = height;
        texture.channel_count = channel_count;
        texture.generation += 1;

        return true;
    }

    /// Destroy a texture and free all associated resources
    pub fn destroyTexture(self: *MetalBackend, texture: *resource_types.Texture) void {
        _ = self;

        if (texture.internal_data) |data| {
            const metal_tex: *metal_texture.MetalTexture = @ptrCast(@alignCast(data));
            metal_texture.destroy(metal_tex);
            std.heap.page_allocator.destroy(metal_tex);
            texture.internal_data = null;
        }
    }

    /// Bind a texture for rendering
    pub fn bindTexture(self: *MetalBackend, texture: ?*const resource_types.Texture) void {
        const encoder = self.context.current_render_encoder orelse return;

        const tex = if (texture) |t| blk: {
            if (t.internal_data) |data| {
                break :blk @as(*const metal_texture.MetalTexture, @ptrCast(@alignCast(data)));
            }
            break :blk &self.default_texture;
        } else &self.default_texture;

        metal_texture.bind(encoder, tex);
    }

    /// Draw geometry using its GPU buffers with a model matrix
    pub fn drawGeometry(self: *MetalBackend, geo: *const geometry_types.Geometry, model_matrix: *const math_types.Mat4) void {
        const encoder = self.context.current_render_encoder orelse return;

        // Push model matrix via setVertexBytes (buffer index 1)
        const push_constant = metal_pipeline.PushConstantObject{
            .model = model_matrix.*,
        };
        metal_pipeline.pushConstants(encoder, &push_constant);

        // Bind and draw geometry
        self.bindGeometry(geo);

        // Issue draw call
        if (geo.index_count > 0) {
            // Get index buffer from geometry's internal data
            if (geo.internal_data) |gpu_data| {
                switch (gpu_data.*) {
                    .metal => |mtl_data| {
                        if (mtl_data.index_buffer.handle) |index_handle| {
                            // drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:
                            msg5(
                                void,
                                encoder,
                                sel("drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:"),
                                metal_context.MTLPrimitiveType.Triangle,
                                @as(u64, geo.index_count),
                                metal_context.MTLIndexType.UInt32,
                                index_handle,
                                @as(u64, 0), // indexBufferOffset
                            );
                        } else {
                            logger.warn("drawGeometry: no index buffer handle for geo id={}", .{geo.id});
                        }
                    },
                    .vulkan => {
                        logger.warn("drawGeometry: geometry has vulkan buffers but using Metal backend", .{});
                    },
                    else => {},
                }
            } else {
                logger.warn("drawGeometry: no internal_data for geo id={}", .{geo.id});
            }
        } else {
            // Non-indexed draw: drawPrimitives:vertexStart:vertexCount:
            msg3(
                void,
                encoder,
                sel("drawPrimitives:vertexStart:vertexCount:"),
                metal_context.MTLPrimitiveType.Triangle,
                @as(u64, 0), // vertexStart
                @as(u64, geo.vertex_count),
            );
        }
    }

    /// Bind geometry buffers for drawing
    pub fn bindGeometry(self: *MetalBackend, geo: *const geometry_types.Geometry) void {
        const encoder = self.context.current_render_encoder orelse return;

        // Buffer indices must match pipeline vertex descriptor:
        // 0 = GlobalUBO, 1 = PushConstants, 2 = Vertex data
        const VERTEX_BUFFER_INDEX: u64 = 2;

        // Get Metal buffers from geometry's internal data
        if (geo.internal_data) |gpu_data| {
            switch (gpu_data.*) {
                .metal => |mtl_data| {
                    // Bind vertex buffer at index 2 (matching vertex descriptor)
                    if (mtl_data.vertex_buffer.handle) |vertex_handle| {
                        msg3(
                            void,
                            encoder,
                            sel("setVertexBuffer:offset:atIndex:"),
                            vertex_handle,
                            @as(u64, 0),
                            VERTEX_BUFFER_INDEX,
                        );
                    }
                },
                else => {},
            }
        }
    }

    /// Get the current frame index
    pub fn getCurrentFrame(self: *MetalBackend) u32 {
        return @intCast(self.frame_number % metal_context.MAX_FRAMES_IN_FLIGHT);
    }

    /// Get the current image index (same as frame for Metal)
    pub fn getImageIndex(self: *MetalBackend) u32 {
        return self.getCurrentFrame();
    }

    // =========================================================================
    // Private helper functions
    // =========================================================================

    fn createMetalLayer(self: *MetalBackend) bool {
        logger.debug("Creating Metal layer...", .{});

        const window_ptr = engine_context.get().platform_window orelse {
            logger.err("No platform window available for Metal layer creation.", .{});
            return false;
        };
        const window: *glfw.GLFWwindow = @ptrCast(@alignCast(window_ptr));

        var width: c_int = 0;
        var height: c_int = 0;
        glfw.glfwGetFramebufferSize(window, &width, &height);
        self.context.framebuffer_width = @intCast(width);
        self.context.framebuffer_height = @intCast(height);

        const ns_window = glfw.glfwGetCocoaWindow(window);
        if (ns_window == null) {
            logger.err("Failed to get Cocoa window from GLFW.", .{});
            return false;
        }

        const content_view = msg(?*anyopaque, ns_window, sel("contentView"));
        if (content_view == null) {
            logger.err("Failed to get content view from NSWindow.", .{});
            return false;
        }

        const ca_metal_layer_class = getClass("CAMetalLayer") orelse {
            logger.err("Failed to get CAMetalLayer class.", .{});
            return false;
        };

        const layer_alloc = msg(?*anyopaque, ca_metal_layer_class, sel("alloc"));
        if (layer_alloc == null) {
            logger.err("Failed to allocate CAMetalLayer.", .{});
            return false;
        }

        const layer = msg(?*anyopaque, layer_alloc, sel("init"));
        if (layer == null) {
            logger.err("Failed to initialize CAMetalLayer.", .{});
            return false;
        }

        _ = msg1(void, layer, sel("setDevice:"), self.context.device);
        // Use sRGB pixel format for gamma-correct rendering (matches Vulkan's B8G8R8A8_SRGB)
        _ = msg1(void, layer, sel("setPixelFormat:"), metal_context.MTLPixelFormat.BGRA8Unorm_sRGB);
        _ = msg1(void, layer, sel("setFramebufferOnly:"), @as(i8, 1));

        // Get the window's backing scale factor for Retina displays
        const scale_factor = msg(f64, ns_window, sel("backingScaleFactor"));
        _ = msg1(void, layer, sel("setContentsScale:"), scale_factor);

        const size = metal_context.CGSize{
            .width = @floatFromInt(self.context.framebuffer_width),
            .height = @floatFromInt(self.context.framebuffer_height),
        };
        _ = msg1(void, layer, sel("setDrawableSize:"), size);

        // Set layer first, then wantsLayer (order matters)
        _ = msg1(void, content_view, sel("setWantsLayer:"), @as(i8, 1));
        _ = msg1(void, content_view, sel("setLayer:"), layer);

        self.context.layer = layer;
        logger.info("Metal layer created and attached to window.", .{});
        return true;
    }

    fn createDepthTexture(self: *MetalBackend) bool {
        const device = self.context.device orelse return false;
        const width = self.context.framebuffer_width;
        const height = self.context.framebuffer_height;

        if (width == 0 or height == 0) return true;

        const desc_class = getClass("MTLTextureDescriptor") orelse return false;

        const desc = msg4(
            ?*anyopaque,
            desc_class,
            sel("texture2DDescriptorWithPixelFormat:width:height:mipmapped:"),
            metal_context.MTLPixelFormat.Depth32Float,
            @as(u64, width),
            @as(u64, height),
            @as(i8, 0),
        );
        if (desc == null) {
            logger.err("Failed to create depth texture descriptor", .{});
            return false;
        }

        _ = msg1(void, desc, sel("setUsage:"), metal_context.MTLTextureUsage.RenderTarget);
        _ = msg1(void, desc, sel("setStorageMode:"), @as(u64, 2)); // MTLStorageModePrivate

        const texture = msg1(?*anyopaque, device, sel("newTextureWithDescriptor:"), desc);
        if (texture == null) {
            logger.err("Failed to create depth texture", .{});
            return false;
        }

        self.context.depth_texture = texture;
        logger.debug("Created depth texture {}x{}", .{ width, height });
        return true;
    }

    fn loadShaders(self: *MetalBackend) bool {
        // Load vertex shader
        const vertex_result = metal_shader.loadFromMSL(
            &self.context,
            "build/shaders/Builtin.MaterialShader.vert.msl",
            "main0",
        );
        if (vertex_result) |vs| {
            self.vertex_shader = vs;
            self.vertex_shader.stage = .vertex;
        } else {
            logger.err("Failed to load vertex shader", .{});
            return false;
        }

        // Load fragment shader
        const fragment_result = metal_shader.loadFromMSL(
            &self.context,
            "build/shaders/Builtin.MaterialShader.frag.msl",
            "main0",
        );
        if (fragment_result) |fs| {
            self.fragment_shader = fs;
            self.fragment_shader.stage = .fragment;
        } else {
            logger.err("Failed to load fragment shader", .{});
            metal_shader.destroy(&self.vertex_shader);
            return false;
        }

        logger.info("Shaders loaded successfully.", .{});
        return true;
    }

    fn createPipeline(self: *MetalBackend) bool {
        const pipeline_result = metal_pipeline.createMaterialPipeline(
            &self.context,
            self.vertex_shader.function,
            self.fragment_shader.function,
            metal_context.MTLPixelFormat.BGRA8Unorm_sRGB, // Use sRGB for gamma-correct rendering
            metal_context.MTLPixelFormat.Depth32Float,
        );

        if (pipeline_result) |p| {
            self.material_pipeline = p;
            logger.info("Pipeline created successfully.", .{});
            return true;
        } else {
            logger.err("Failed to create pipeline", .{});
            return false;
        }
    }

    fn createUniformBuffers(self: *MetalBackend) bool {
        // Use shared GlobalUBO from renderer module
        const ubo_size = @sizeOf(renderer.GlobalUBO);

        for (&self.global_uniform_buffers) |*buf| {
            buf.* = metal_buffer.createEmpty(&self.context, ubo_size);
            if (!metal_buffer.isValid(buf)) {
                logger.err("Failed to create uniform buffer", .{});
                return false;
            }
        }

        logger.debug("Created {} uniform buffers ({} bytes each)", .{ metal_context.MAX_FRAMES_IN_FLIGHT, ubo_size });
        return true;
    }

    pub fn updateUBO(self: *MetalBackend, ubo: *const renderer.GlobalUBO) void {
        const frame_idx = self.context.frame_index;
        const buf = &self.global_uniform_buffers[frame_idx];

        metal_buffer.update(buf, 0, @sizeOf(renderer.GlobalUBO), ubo);
    }

    // =========================================================================
    // ImGui Integration (conditional on build_options.enable_imgui)
    // =========================================================================

    /// Initialize ImGui with GLFW and Metal backends
    pub fn initImGui(self: *MetalBackend) bool {
        if (!build_options.enable_imgui) {
            return true; // No-op success when ImGui is disabled
        }

        const window_ptr = engine_context.get().platform_window orelse {
            logger.err("ImGui: No platform window available", .{});
            return false;
        };

        const device = self.context.device orelse {
            logger.err("ImGui: No Metal device available", .{});
            return false;
        };

        // Initialize GLFW backend for input handling
        // Use InitForOther since we're using Metal, not OpenGL
        // Note: install_callbacks=false because we forward events from platform.zig callbacks
        if (!imgui_glfw.cImGui_ImplGlfw_InitForOther(@ptrCast(window_ptr), false)) {
            logger.err("ImGui: Failed to initialize GLFW backend", .{});
            return false;
        }

        // Initialize Metal backend for rendering
        if (!imgui_metal.cImGui_ImplMetal_Init(device)) {
            logger.err("ImGui: Failed to initialize Metal backend", .{});
            imgui_glfw.cImGui_ImplGlfw_Shutdown();
            return false;
        }

        self.imgui_initialized = true;
        logger.info("ImGui Metal backend initialized", .{});
        return true;
    }

    /// Shutdown ImGui backends
    pub fn shutdownImGui(self: *MetalBackend) void {
        if (!build_options.enable_imgui) return;
        if (!self.imgui_initialized) return;

        imgui_metal.cImGui_ImplMetal_Shutdown();
        imgui_glfw.cImGui_ImplGlfw_Shutdown();

        self.imgui_initialized = false;
        logger.info("ImGui Metal backend shutdown", .{});
    }

    /// Begin ImGui frame - must be called before ImGui::NewFrame()
    pub fn beginImGuiFrame(self: *MetalBackend) void {
        if (!build_options.enable_imgui) return;
        if (!self.imgui_initialized) {
            logger.warn("ImGui beginFrame called but not initialized", .{});
            return;
        }

        // Order matters! GLFW first (input), then Metal (rendering)
        // Process GLFW input first
        imgui_glfw.cImGui_ImplGlfw_NewFrame();

        // Then Metal backend frame
        // We need to pass the render pass descriptor so it knows the framebuffer format
        if (self.imgui_render_pass_desc) |rpd| {
            imgui_metal.cImGui_ImplMetal_NewFrame(rpd);
        } else {
            logger.warn("ImGui: No render pass descriptor available", .{});
        }
    }

    /// Render ImGui draw data using Metal
    pub fn renderImGui(self: *MetalBackend, draw_data: ?*anyopaque) void {
        if (!build_options.enable_imgui) return;
        if (!self.imgui_initialized) return;
        if (draw_data == null) return;

        const command_buffer = self.context.current_command_buffer orelse return;
        const encoder = self.context.current_render_encoder orelse return;

        imgui_metal.cImGui_ImplMetal_RenderDrawData(draw_data, command_buffer, encoder);
    }
};

// External C function from Metal framework
extern "c" fn MTLCreateSystemDefaultDevice() ?*anyopaque;
